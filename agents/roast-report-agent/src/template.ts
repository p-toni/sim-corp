import type {
  EventOverride,
  RoastAnalysis,
  RoastReport,
  RoastSession,
  SessionMeta,
  SessionNote
} from "@sim-corp/schemas";

const MAX_ACTIONS = 5;

export interface ReportTemplateInput {
  session: RoastSession;
  analysis: RoastAnalysis;
  meta?: SessionMeta;
  overrides: EventOverride[];
  notes: SessionNote[];
  agentName: string;
  agentVersion: string;
}

export function renderReport(input: ReportTemplateInput): Pick<RoastReport, "markdown" | "nextActions"> {
  const { session, analysis, meta, overrides, notes, agentName, agentVersion } = input;
  const nextActions = deriveNextActions(analysis);
  const latestNote = notes[0];

  const markdownSections = [
    `# Roast Report — ${session.sessionId}`,
    `*Generated by ${agentName} v${agentVersion} at ${new Date().toISOString()}*`,
    "",
    "## Summary",
    [
      `- Machine: ${session.machineId} (${session.siteId})`,
      `- Started: ${session.startedAt} | Ended: ${session.endedAt ?? "—"}`,
      `- Duration: ${formatSeconds(analysis.totalDurationSeconds ?? session.durationSeconds)}s`,
      `- FC: ${formatSeconds(analysis.fcSeconds ?? session.fcSeconds)}s | DROP: ${formatSeconds(analysis.dropSeconds ?? session.dropSeconds)}s`,
      `- Development ratio: ${formatRatio(analysis.developmentRatio)}`,
      `- Max BT: ${formatNumber(analysis.maxBtC ?? session.maxBtC)}°C`
    ].join("\n"),
    "",
    "## Phases",
    renderPhases(analysis),
    "",
    "## Warnings",
    renderWarnings(analysis),
    "",
    "## Recommendations",
    renderRecommendations(analysis),
    "",
    "## QC Notes",
    latestNote ? renderNote(latestNote) : "- No QC notes recorded.",
    "",
    "## Overrides",
    renderOverrides(overrides),
    "",
    "## Next Roast Plan (v1)",
    nextActions.length
      ? nextActions.map((action) => `- [${action.confidence}] ${action.message}`).join("\n")
      : "- Keep profile; no risky adjustments identified."
  ];

  return {
    markdown: markdownSections.join("\n"),
    nextActions
  };
}

function renderPhases(analysis: RoastAnalysis): string {
  if (!analysis.phaseStats?.length) {
    return "- Phase stats unavailable.";
  }
  const header = "| Phase | Duration (s) | ΔBT (°C) | Avg RoR | Smoothness |\n| --- | --- | --- | --- | --- |";
  const rows = analysis.phaseStats.map((stat) => {
    return `| ${stat.phase} | ${formatNumber(stat.durationSeconds)} | ${formatNumber(stat.btDeltaC)} | ${formatNumber(stat.avgRorCPerMin)} | ${formatNumber(stat.rorSmoothnessScore, 2)} |`;
  });
  return [header, ...rows].join("\n");
}

function renderWarnings(analysis: RoastAnalysis): string {
  const warnings = [...(analysis.warnings ?? [])];
  if (analysis.crashFlick.crashDetected) {
    warnings.push({
      code: "CRASH",
      severity: "ALERT",
      message: "Crash detected after FC",
      atSeconds: analysis.crashFlick.crashAtSeconds,
      details: {}
    });
  }
  if (analysis.crashFlick.flickDetected) {
    warnings.push({
      code: "FLICK",
      severity: "WARN",
      message: "Flick detected late in roast",
      atSeconds: analysis.crashFlick.flickAtSeconds,
      details: {}
    });
  }
  if (!warnings.length) {
    return "- None.";
  }
  return warnings
    .map((w) => `- [${w.severity}] ${w.code}: ${w.message}${w.atSeconds ? ` @ ${formatSeconds(w.atSeconds)}s` : ""}`)
    .join("\n");
}

function renderRecommendations(analysis: RoastAnalysis): string {
  const recs = analysis.recommendations ?? [];
  if (!recs.length) {
    return "- None.";
  }
  return recs.map((r) => `- [${r.confidence}] ${r.code}: ${r.message}`).join("\n");
}

function renderOverrides(overrides: EventOverride[]): string {
  if (!overrides.length) {
    return "- None.";
  }
  const header = "| Event | Elapsed (s) | Source | Author | Reason |\n| --- | --- | --- | --- | --- |";
  const rows = overrides.map((o) => {
    return `| ${o.eventType} | ${formatNumber(o.elapsedSeconds)} | ${o.source ?? "HUMAN"} | ${o.author ?? "—"} | ${o.reason ?? "—"} |`;
  });
  return [header, ...rows].join("\n");
}

function renderNote(note: SessionNote): string {
  const parts = [
    `- ${note.title ?? "Note"} (${note.createdAt})`,
    note.text ? `  - ${note.text}` : null,
    typeof note.cuppingScore === "number" ? `  - Cupping: ${note.cuppingScore}` : null,
    note.defects?.length ? `  - Defects: ${note.defects.join(", ")}` : null
  ].filter(Boolean);
  return parts.join("\n");
}

function deriveNextActions(analysis: RoastAnalysis): RoastReport["nextActions"] {
  const actions: RoastReport["nextActions"] = [];

  if (analysis.crashFlick.crashDetected) {
    actions.push({
      code: "AVOID_CRASH",
      message: "Avoid steep heat reduction after FC; smooth the post-FC gas taper.",
      confidence: "HIGH",
      details: {}
    });
  }

  if (analysis.crashFlick.flickDetected) {
    actions.push({
      code: "STABILIZE_POST_FC_HEAT",
      message: "Avoid late heat bumps; hold airflow stable after FC to prevent flick.",
      confidence: "MED",
      details: {}
    });
  }

  if (typeof analysis.developmentRatio === "number") {
    if (analysis.developmentRatio < 0.2) {
      actions.push({
        code: "EXTEND_DEVELOPMENT",
        message: "Extend development ~5-10s or reduce heat during Maillard to boost development ratio.",
        confidence: "MED",
        details: { developmentRatio: analysis.developmentRatio }
      });
    } else if (analysis.developmentRatio > 0.26) {
      actions.push({
        code: "SHORTEN_DEVELOPMENT",
        message: "Pull drop slightly earlier or flatten late heat to avoid overdevelopment.",
        confidence: "MED",
        details: { developmentRatio: analysis.developmentRatio }
      });
    }
  }

  const lowSmoothness = analysis.phaseStats.find(
    (stat) => typeof stat.rorSmoothnessScore === "number" && stat.rorSmoothnessScore < 0.5
  );
  if (lowSmoothness) {
    actions.push({
      code: "SMOOTHER_CONTROL",
      message: "Reduce control oscillations; make smaller, slower gas/air changes in Maillard.",
      confidence: "LOW",
      details: { phase: lowSmoothness.phase, smoothness: lowSmoothness.rorSmoothnessScore }
    });
  }

  const warningActionNeeded = (analysis.warnings ?? []).some(
    (w) => w.severity === "ALERT" || w.severity === "WARN"
  );
  if (warningActionNeeded && actions.length < MAX_ACTIONS) {
    actions.push({
      code: "REVIEW_WARNINGS",
      message: "Address roast warnings before next run; ensure sensors and operator notes are in sync.",
      confidence: "LOW",
      details: { warnings: analysis.warnings?.length ?? 0 }
    });
  }

  return actions.slice(0, MAX_ACTIONS);
}

function formatSeconds(value?: number): string {
  if (typeof value !== "number" || Number.isNaN(value)) return "—";
  return value.toFixed(0);
}

function formatNumber(value: number | undefined, digits = 1): string {
  if (typeof value !== "number" || Number.isNaN(value)) return "—";
  return value.toFixed(digits);
}

function formatRatio(value?: number): string {
  if (typeof value !== "number" || Number.isNaN(value)) return "—";
  return value.toFixed(2);
}
